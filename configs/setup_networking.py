#!/usr/bin/python3 -tt
"""
    Create TFTP environment for nodes to pick up custom FS images.
This script generates node-specific the grub menu files plus a single master
grub.cfg.  It also generates config files for the PXE server "dnsmasq".

Details: SFW constructs a ClientID based on the node's physical coordinates.
That ClientID is passed in a DHCP request.  The DHCP server (dnsmasq) looks
up an IP address and hostname based on ClientID.  The DHCP response also
includes a TFTP server (also dnsmasq) from which to obtain a boot loader.

SFW downloads (via TFTP) a single file, the bootloader which is "grub".
Grub turns around and TFTPs the master grub.cfg file common to all nodes.
grub.cfg evaluates the hostname of the running node to choose a menu file.
That menu specifies the precise kernel file (vmlinuz) and customized FS image
(.cpio file) for the node.
"""

import argparse
import os
import requests as HTTP_REQUESTS
import sys
import time

import dns.resolver as RES
from netaddr import IPNetwork, iter_iprange, IPAddress
import netifaces as NIF

from pdb import set_trace

from tm_librarian.tmconfig import TMConfig

# Imports are relative to parent directory with setup.py because implicit
# Python path "tmms" may not exist yet.

from configs.build_config import ManifestingConfiguration
from utils.utils import basepath, piper
from utils.file_utils import make_symlink, make_dir

_maxnodes = 40  # Revised FRD for 2016

###########################################################################
# Templates for config files

# /boot/grub.cfg ----------------------------------------------------------
# bootnetaa64.efi is compiled with most modules, such as all_video.   A few
# (like videoinfo) might be needed, so the modules directory will be supplied.
# Sometimes the EFI network is 0, sometimes 1, and I can't get
# inline variable substitution to work.  Take the easy way out,
# one of them will fire.

_grub_cfg_template = '''
# Command/data prefix is (tftp)/grub; module prefix is (tftp)/grub/arm64-efi
# so "insmod videoinfo" just works.  Both TMAS and FAME have a countdown
# multiplier of about ten, and there's not really any menu choices, so

set timeout=1

set gfxmode=auto
set gfxmodepayload=text
set linux_gfx_mode=text

# Fails on TMAS, no video modes per "videoinfo"
terminal_output gfxterm
background_image "(tftp)/grub/manifest.jpg"

configfile  "(tftp){menudir}/${{net_efinet0_hostname}}.menu"
configfile  "(tftp){menudir}/${{net_efinet1_hostname}}.menu"
'''

# /grub/menus/nodeXX.menu -------------------------------------------------
# First cut was "root=/dev/ram0" but that invokes (old, inflexible) ramfs
# behavior.  "mount" claims that / is type rootfs (a special kind of tmpfs)
# but "df /" is nothing but zeroes.  From 2013:
# https://lwn/net/Articles/559176/ says don't specify root= but DO specify
# rootfstype=tmpfs (assumes CONFIG_TMPFS). df is now happy, although mount
# claims / is type rootfs.  As it turns out, specifying neither root= or
# rootfstype= works just fine.

_grub_menu_template = '''
set default=0
# FAME and TMAS jack this X10.  Real HW will not care.
set timeout=1

set menu_color_highlight=white/brown

menuentry '{hostname} L4TM ARM64' {{
    linux (tftp){images_dir}/{hostname}.vmlinuz.gz console=ttyAMA0 acpi=force rw
    initrd (tftp){images_dir}/{hostname}.cpio.gz
}}
'''

# .../dnsmasq/<INTERFACE>.conf and more -----------------------------------
# Main grub.cfg template was started from a libvirt NAT setup.  See also
# https://github.com/ussjoin/piglet/blob/master/config/dnsmasq.conf
# dnsmasq --help dhcp

_dnsmasq_conf_template = '''# Auto-generated by {user} on {timestamp}

pid-file=/var/run/tmms/dnsmasq.{pxe_interface}.pid
log-facility=/var/log/tmms/dnsmasq.{pxe_interface}.log
# log-dhcp

bind-interfaces
interface={pxe_interface}
except-interface=lo
local-service

# resolv.conf handling
# resolv-file=
# no-poll
# strict-order
all-servers

domain={tmdomain}
clear-on-reload
# never forward simple names
domain-needed
# srv-host=_librarian._tcp,torms,9093
selfmx

dhcp-leasefile=/var/lib/tmms/dnsmasq/{pxe_interface}.leases
dhcp-script=/bin/echo		# "add|del" MAC IP hostname
dhcp-range={first_addr},static   # sets IPV4 mode, but only from hostsfile
dhcp-match=TMAS-EFI,option:client-arch,11		# EFI
dhcp-hostsfile=/var/lib/tmms/dnsmasq/{pxe_interface}.hostsfile
addn-hosts=/var/lib/tmms/dnsmasq/{pxe_interface}.dnslookup
dhcp-no-override
dhcp-boot=/grub/grubnetaa64.efi
# 512-byte blocks.  TM SFW does ask but it's not done automatically
dhcp-option-force=option:boot-file-size,{boot_file_size_512_blocks}

enable-tftp
tftp-root={tftp_root}
'''

# /var/lib/tmms/dnsmasq/<PXE_INTERFACE>.iptables --------------------------
# Created libvirt networks of forward=route with DHCP to get FW rules to
# isolate DHCP on the given network.

_iptables_template = '''# Auto-generated by {user} on {timestamp}
-t mangle -{{action}} POSTROUTING -o {pxe_interface} -p udp -m udp --dport 68 -j CHECKSUM --checksum-fill
-t filter -{{action}} INPUT -i {pxe_interface} -p udp -m udp --dport 53 -j ACCEPT
-t filter -{{action}} INPUT -i {pxe_interface} -p tcp -m tcp --dport 53 -j ACCEPT
-t filter -{{action}} INPUT -i {pxe_interface} -p udp -m udp --dport 67 -j ACCEPT
-t filter -{{action}} INPUT -i {pxe_interface} -p tcp -m tcp --dport 67 -j ACCEPT
-t filter -{{action}} FORWARD -d {network} -o {pxe_interface} -j ACCEPT
-t filter -{{action}} FORWARD -s {network} -i {pxe_interface} -j ACCEPT
-t filter -{{action}} FORWARD -i {pxe_interface} -o {pxe_interface} -j ACCEPT
-t filter -{{action}} FORWARD -o {pxe_interface} -j REJECT --reject-with icmp-port-unreachable
-t filter -{{action}} FORWARD -i {pxe_interface} -j REJECT --reject-with icmp-port-unreachable
-t filter -{{action}} OUTPUT -o {pxe_interface} -p udp -m udp --dport 68 -j ACCEPT
'''

#--------------------------------------------------------------------------


class TMgrub(object):
    """
        Generate all grub grub config files under the TFTP hierarchy.
        At "tftp" element of hierarchy (default /var/lib/tmms/tftp):
        - grub/
          grubnetaa64.efi
          grub.cfg
          - menus/
            node01.menu thru node40.menu
        -images/
          - nodeXX/ (directories)
            nodeXX.vmlinuz and nodeXX.cpio
    """

    def __init__(self, manconfig):
        """
        :param 'manconfig': dictionary with many ratified paths and other data
        """

        self.user = os.getlogin()
        self.timestamp = time.ctime()
        self.tmconfig = TMConfig(manconfig['TMCONFIG'])

        # Absolute paths are for writing files.  tftp_xxxx are file contents.
        # Dirs keyed from manconfig were already created.
        self.tftp_images_dir = manconfig['TFTP_IMAGES']
        self.tftp_grub_dir = manconfig['TFTP_GRUB']     # already created
        self.tftp_grub_menus_dir = self.tftp_grub_dir + '/menus'
        make_dir(self.tftp_grub_menus_dir)
        make_symlink(   # Present all EFI modules to grub for "insmod"
            '/usr/lib/grub/arm64-efi', self.tftp_grub_dir + '/arm64-efi')

        self.tftp_grub_cfg = self.tftp_grub_dir + '/grub.cfg'
        self.tftp_grub_efi = self.tftp_grub_dir + '/grubnetaa64.efi'

        self.dnsmasq_dir = manconfig['DNSMASQ_CONFIGS']
        self.pxe_interface = manconfig['PXE_INTERFACE']
        self.tmdomain = manconfig['TMDOMAIN']

        # Relative to TFTP, these supply content to the files.
        self.tftp_root = manconfig['TFTP_ROOT']
        self.chroot_images_dir = basepath(self.tftp_images_dir, self.tftp_root)
        self.chroot_grub_dir = basepath(self.tftp_grub_dir, self.tftp_root)
        self.chroot_grub_menus_dir = basepath(
            self.tftp_grub_menus_dir, self.tftp_root)

        # This file is also in the Debian package "grub-efi-arm64-signed"
        # (w/ appropriate revision) but Linn Crosetto keeps it here.
        # The grub-mkimage command is in the source deb under build/xxxx

        grubURL = manconfig['L4TM_MIRROR'] + \
            '/dists/catapult/main/uefi/grub2-arm64/' +\
            'current/grubnetaa64.efi.signed'
        try:
            r = HTTP_REQUESTS.get(grubURL)
            assert r.status_code == 200, 'Cannot retrieve "%s"' % grubURL
            assert len(r.content) == int(r.headers['Content-Length']), \
                'Length mismatch on "%s"' % grubURL
        except Exception as e:
            raise SystemExit(str(e))
        with open(self.tftp_grub_efi, 'wb') as f:
            f.write(r.content)

    @property
    def hostnames(self):
        return ('node%02d' % n for n in range(1, 41))   # generator

    def evaluate_TMDOMAIN(self):
        '''
        manifest_config.py TTMDOMAIN variable has simple form like
           TMDOMAIN = 'have.it.your.way'
        By decree of the LATC, TMCF contains no MAC or IP addresses,
        only hostnames.  There is only hostname to IP address binding.
        The authoritative source for that is DNS, as set up by HPE site IT,
        since all instances of The Machine will always be connected to
        HPE site LAN.  Thus given the domain name, each host IP can be
        resolved by DNS.  40 nodes must be available in DNS.

        In case DNS is not prepped properly :-), one extended element is
        available in the TMDOMAIN data as a CSV.  It has two variants:
        1) Domain,ipaddr : TMDOMAIN = 'have.it.your.way,192.168.122.111'
           grab 40 IP addresses starting at ipaddr
           assumes class C netmask
        2) Domain,ipaddr/bits: TMDOMAIN = 'have.it.your.way,10.11.10.42/24'
           grab 40 IPs @ ipaddr
           netmask from bits
           if ipaddr is the network zero address, first address is x.y.z.1

           Each case has its own method to calculate a network CIDR.
        '''

        elems = self.tmdomain.split(',')    # elems may have leftovers
        self.tmdomain = elems.pop(0)

        self.hostIPs = []
        if not elems:           # No extension == DNS lookup for all nodes
            for num in range(1, _max_nodes + 1):
                FQDN = 'node%02d.%s' % (num, self.tmdomain)
                try:    # dns.resolver is weird, even with raise_on_no_answer
                    answer = RES.query(FQDN, 'A')
                    assert len(answer) == 1, '"%s" has CNAMES' % FQDN
                except Exception as e:
                    raise RuntimeError('TMDOMAIN: cannot resolve "%s"' % FQDN)
                A = next(iter(answer))
                self.hostIPs.append(A.address)
            # Oh yeah...
            try:
                FQDN = 'torms.' + self.tmdomain
                answer = RES.query(FQDN, 'A')
                assert len(answer) == 1
                self.torms = str(next(iter(answer)).address)
            except Exception as e:
                raise RuntimeError('TMDOMAIN: cannot resolve "%s"' % FQDN)

            # Since this is Corporate IT, assume the position.
            # Any of the address above will do.
            kludge_network = IPNetwork(
                str(self.hostIPs[0]) + '/255.255.240.0').cidr

        else:   # Extended element(s) are available
            assert len(elems) == 1, 'Too many CSV fields in TMDOMAIN'
            tmp = elems[0]

            if '/' in tmp:      # CIDR network, load and check
                try:
                    kludge_network = IPNetwork(tmp).cidr
                    tmp = tmp.split('/')[0]
                    if tmp != str(IPAddress(kludge_network.first)):
                        first_addr = IPAddress(tmp)
                    else:
                        first_addr = IPAddress(kludge_network.first + 1)
                except Exception as e:
                    raise RuntimeError(
                        'TMDOMAIN: bad CIDR notation: %s' % str(e))

            else:   # Single IP address, assume class C
                try:
                    first_addr = IPAddress(tmp)
                except Exception as e:
                    raise RuntimeError(
                        'TMDOMAIN: illegal IP address notation: %s' % str(e))
                kludge_network = IPNetwork(tmp + '/255.255.255.0').cidr

        if self.network is None:
            self.network = kludge_network
        else:
            assert self.network == kludge_network, \
                'Networking mismatch between NIC and TMDOMAIN'
        if not self.hostIPs:    # enumerator properly skips Sun broadcast
            self.hostIPs = [IPAddress(first_addr.value + i)
                                for i in range(_maxnodes)]
            assert all(map(lambda a: a in self.network, self.hostIPs)), \
                'Auto-generated IP address extend beyond network'
        self.first_addr = str(self.hostIPs[0])

    def configure_dnsmasq(self, prepath):
        # Try to carry on in the face of errors.  dnsmasq may not start but
        # manifest_api should still run.
        self.torms = None
        self.addr = None        # Might become a string
        self.network = None     # WILL become an IPNetwork object
        try:
            assert self.pxe_interface in NIF.interfaces(), \
                'PXE_INTERFACE: no such interface "%s"' % self.pxe_interface
            ifaceaddr = NIF.ifaddresses(
                self.pxe_interface).get(NIF.AF_INET, False)
            if ifaceaddr:
                assert len(ifaceaddr) == 1, \
                    'PXE_INTERFACE "%s" has multiple IPs assigned to it' % \
                    self.pxe_interface
                ifaceaddr = ifaceaddr.pop()
                self.addr = ifaceaddr['addr']      # Convenience attrs
                # Check the __doc__ string for this class.  It's AWESOME!
                self.network = IPNetwork(
                    self.addr + '/' + ifaceaddr['netmask'])
                self.torms = str(self.addr)
        except Exception as e:
            print(str(e))

        self.evaluate_TMDOMAIN()

        assert len(self.hostIPs) == _maxnodes, \
            'TMDOMAIN form yielded %d IP addresses, not %d' % (
                len(self.hostIPs), _maxnodes)

        size = os.stat(self.tftp_grub_efi).st_size
        self.boot_file_size_512_blocks = (size // 512) + 1

        conf = _dnsmasq_conf_template.format(**vars(self))

        with open(prepath + '.conf', 'w') as f:
            f.write(conf)

        # AA programs MFW with "rack prefix".  MFW appends EncNum/X/Node/Y.
        # The rack enumerator and "Enclosure" locator are omitted.  Maybe.
        nodefmt = '%s/EncNum/%%d/Node/%%d' % self.tmconfig.racks[1].coordinate
        self.coords = [nodefmt % ((i // 10) + 1, (i % 10) + 1)
                       for i in range(_maxnodes)]
        # TM SFW will not run under QEMU/FAME.   Fall back to MAC-based
        # assignments (since we own the MACs in this case).
        self.MACs = ['52:54:48:50:45:%02d' % (i + 1)
                       for i in range(_maxnodes)]
        # MAC and ClientID must be on the same line or else dnsmasq bitches
        # about duplicate IPs and skips the second set.
        zipped = zip(self.MACs, self.coords, self.hostIPs, self.hostnames)
        with open(prepath + '.hostsfile', 'w') as f:
            f.write('# FAME/QEMU MAC,ClientID,IP address, hostname\n')
            for h in zipped:
                f.write('%s,id:%s,%s,%s\n' % h)

        # Static assignments.  First and foremost torms, but without these
        # dnsmasq only resolves requests for running nodes.
        with open(prepath + '.dnslookup', 'w') as f:
            f.write('# Auto-generated by {user} on {timestamp}\n'.format(
                 **vars(self)))
            f.write('%s\ttorms\n' % self.torms)
            for i, ip in enumerate(self.hostIPs):
                f.write('%s\tnode%02d\n' % (str(ip), i + 1))

    def configure_iptables(self, prepath):
        '''Create the meat of "iptables -A" or "iptables -D".'''
        tmp = _iptables_template.format(**vars(self))
        with open(prepath + '.iptables', 'w') as f:
            f.write(tmp)

    def create_tftp_environment(self):
        """
            Create subdirectories under TFTP and add grub menu files based on
        node's hostname, which is implicitly the node's physical location.
        These files are static over the lifetime of a machine instance. Then
        create filesystem image directories per these coords for PXE boot
        to pick up on boot .cpio and .vmlinuz.  manifest_api will populate
        those directories when nodes are bound.
        """

        grub_cfg_content = self.compose_grub_cfg()
        with open(self.tftp_grub_cfg, 'w') as file_obj:
            file_obj.write(grub_cfg_content)

        for hostname in self.hostnames:
            tftp_node_fs = self.tftp_images_dir + '/' + hostname
            make_dir(tftp_node_fs)
            grub_menu_content = self.compose_grub_menu(hostname)
            menu_fname = '%s/%s.menu' % (self.tftp_grub_menus_dir, hostname)
            with open(menu_fname, 'w') as file_obj:
                file_obj.write(str(grub_menu_content))

        prepath = '%s/%s' % (self.dnsmasq_dir, self.pxe_interface)
        self.configure_dnsmasq(prepath)
        self.configure_iptables(prepath)

    def compose_grub_menu(self, hostname):
        """Return grub menu content keyed on hostname."""
        # Node binding places {hostname}.vmlinuz and {hostname}.cpio here
        images_dir = '%s/%s' % (self.chroot_images_dir, hostname)
        return _grub_menu_template.format(
            hostname=hostname, images_dir=images_dir)

    def compose_grub_cfg(self):
        """
            Template string for a grub.cfg that references grub menu
        for each node on PXE boot.
        """

        return _grub_cfg_template.format(menudir=self.chroot_grub_menus_dir)


def main(args):
    """
        Configure TFTP environment.
    """
    manconfig = ManifestingConfiguration(args.config, autoratify=False)
    missing = manconfig.ratify(dontcare=('GOLDEN_IMAGE', ))
    if missing:
        raise RuntimeError('\n'.join(missing))
    grubby = TMgrub(manconfig)
    grubby.create_tftp_environment()
    print('Master GRUB configuration in', grubby.tftp_grub_cfg)
    print('      Per-node grub menus in', grubby.tftp_grub_menus_dir)
    print('      Per-node image dirs in', grubby.tftp_images_dir)
    if grubby.pxe_interface is None:
        print(
            'dnsmasq config has been suppressed. Fix /etc/tmms[PXE_INTERFACE]')
    else:
        print('  dnsmasq/iptables config in %s/%s.*' % (
            grubby.dnsmasq_dir, grubby.pxe_interface))


if __name__ == '__main__':
    # Not worth working around this
    raise SystemExit('Can only be run from top-level setup.py')
